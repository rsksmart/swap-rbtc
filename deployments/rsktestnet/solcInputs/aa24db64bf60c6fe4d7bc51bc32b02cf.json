{
  "language": "Solidity",
  "sources": {
    "contracts/SwapRBTC.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./ISideToken.sol\";\nimport \"./ISwapRBTC.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract SwapRBTC is Initializable, OwnableUpgradeable, ISwapRBTC, IERC777Recipient {\n  event WrappedBtcChanged(address sideTokenBtc);\n  event RbtcSwapRbtc(address sideTokenBtc, uint256 amountSwapped);\n  event Withdrawal(address indexed src, uint256 wad, address sideTokenBtc);\n  event Received(address sender, uint256 amount);\n  event TokenReceived(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes userData,\n    bytes operatorData\n  );\n\n  IERC1820Registry constant internal ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n  ISideToken public sideTokenBtc; // sideEthereumBTC\n  address internal constant NULL_ADDRESS = address(0);\n\n  function initialize(address sideTokenBtcContract) public initializer {\n    _setSideTokenBtc(sideTokenBtcContract);\n    // keccak256(\"ERC777TokensRecipient\")\n    ERC1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n  }\n\n  receive () external payable {\n\t\t// The fallback function is needed to use WRBTC\n\t\t// require(_msgSender() == address(sideTokenBtc), \"SwapRBTC: not sideBTC address\");\n    emit Received(msg.sender, msg.value);\n\t}\n\n  function _setSideTokenBtc(address sideTokenBtcContract) internal {\n    require(sideTokenBtcContract != NULL_ADDRESS, \"SwapRBTC: sideBTC is null\");\n    sideTokenBtc = ISideToken(sideTokenBtcContract);\n    emit WrappedBtcChanged(sideTokenBtcContract);\n  }\n\n  function setWrappedBtc(address sideTokenBtcContract) public onlyOwner {\n    _setSideTokenBtc(sideTokenBtcContract);\n  }\n\n  function swapWRBTCtoRBTC(uint256 amount) external override returns (uint256) {\n    address payable sender = payable(msg.sender);\n    require(sideTokenBtc.balanceOf(sender) >= amount, \"SwapRBTC: not enough balance\");\n\n    bool successTransfer = sideTokenBtc.transferFrom(sender, address(this), amount);\n    emit Withdrawal(sender, amount, address(sideTokenBtc));\n\n    require(successTransfer, \"SwapRBTC: Transfer sender failed\");\n    require(address(this).balance >= amount, \"SwapRBTC: amount > balance\");\n\n    sideTokenBtc.burn(amount, \"\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool successCall,) = sender.call{value: amount}(\"\");\n    require(successCall, \"SwapRBTC: Swap call failed\");\n    emit RbtcSwapRbtc(address(sideTokenBtc), amount);\n\n    return amount;\n  }\n\n  function getSideTokenBtc() external view override returns (address) {\n    return address(sideTokenBtc);\n  }\n\n  /**\n    * @dev Called by an `IERC777` token contract whenever tokens are being\n    * moved or created into a registered account (`to`). The type of operation\n    * is conveyed by `from` being the zero address or not.\n    *\n    * This call occurs _after_ the token contract's state is updated, so\n    * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\n    *\n    * This function may revert to prevent the operation from being executed.\n  */\n  function tokensReceived(\n    address operator,\n    address from,\n    address to,\n    uint amount,\n    bytes calldata userData,\n    bytes calldata operatorData\n  ) external override {\n    emit TokenReceived(operator, from, to, amount, userData, operatorData);\n  }\n\n}\n"
    },
    "contracts/ISideToken.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface ISideToken {\n  /**\n    * @dev Returns the name of the token.\n  */\n  function name() external view returns (string memory);\n\n  /**\n    * @dev Returns the symbol of the token, usually a shorter version of the\n    * name.\n  */\n  function symbol() external view returns (string memory);\n\n  /**\n    * @dev Returns the smallest part of the token that is not divisible. This\n    * means all token operations (creation, movement and destruction) must have\n    * amounts that are a multiple of this number.\n    *\n    * For most token contracts, this value will equal 1.\n  */\n  function granularity() external view returns (uint256);\n\n  /**\n    * @dev Returns the amount of tokens in existence.\n    */\n  function totalSupply() external view returns (uint256);\n\n  /**\n    * @dev Returns the amount of tokens owned by an account (`owner`).\n    */\n  function balanceOf(address owner) external view returns (uint256);\n\n  /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    *\n    * If send or receive hooks are registered for the caller and `recipient`,\n    * the corresponding functions will be called with `data` and empty\n    * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n    *\n    * Emits a `Sent` event.\n    *\n    * Requirements\n    *\n    * - the caller must have at least `amount` tokens.\n    * - `recipient` cannot be the zero address.\n    * - if `recipient` is a contract, it must implement the `tokensReceived`\n    * interface.\n    */\n  function send(address recipient, uint256 amount, bytes calldata data) external;\n\n  /**\n    * @dev Destroys `amount` tokens from the caller's account, reducing the\n    * total supply.\n    *\n    * If a send hook is registered for the caller, the corresponding function\n    * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\n    *\n    * Emits a `Burned` event.\n    *\n    * Requirements\n    *\n    * - the caller must have at least `amount` tokens.\n  */\n  function burn(uint256 amount, bytes calldata data) external;\n\n  /**\n    * @dev Returns true if an account is an operator of `tokenHolder`.\n    * Operators can send and burn tokens on behalf of their owners. All\n    * accounts are their own operator.\n    *\n    * See `operatorSend` and `operatorBurn`.\n  */\n  function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n  /**\n    * @dev Make an account an operator of the caller.\n    *\n    * See `isOperatorFor`.\n    *\n    * Emits an `AuthorizedOperator` event.\n    *\n    * Requirements\n    *\n    * - `operator` cannot be calling address.\n  */\n  function authorizeOperator(address operator) external;\n\n  /**\n    * @dev Make an account an operator of the caller.\n    *\n    * See `isOperatorFor` and `defaultOperators`.\n    *\n    * Emits a `RevokedOperator` event.\n    *\n    * Requirements\n    *\n    * - `operator` cannot be calling address.\n  */\n  function revokeOperator(address operator) external;\n\n  /**\n    * @dev Returns the list of default operators. These accounts are operators\n    * for all token holders, even if `authorizeOperator` was never called on\n    * them.\n    *\n    * This list is immutable, but individual holders may revoke these via\n    * `revokeOperator`, in which case `isOperatorFor` will return false.\n  */\n  function defaultOperators() external view returns (address[] memory);\n\n  /**\n    * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n    * be an operator of `sender`.\n    *\n    * If send or receive hooks are registered for `sender` and `recipient`,\n    * the corresponding functions will be called with `data` and\n    * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n    *\n    * Emits a `Sent` event.\n    *\n    * Requirements\n    *\n    * - `sender` cannot be the zero address.\n    * - `sender` must have at least `amount` tokens.\n    * - the caller must be an operator for `sender`.\n    * - `recipient` cannot be the zero address.\n    * - if `recipient` is a contract, it must implement the `tokensReceived`\n    * interface.\n  */\n  function operatorSend(\n    address sender,\n    address recipient,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n  /**\n    * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n    * The caller must be an operator of `account`.\n    *\n    * If a send hook is registered for `account`, the corresponding function\n    * will be called with `data` and `operatorData`. See `IERC777Sender`.\n    *\n    * Emits a `Burned` event.\n    *\n    * Requirements\n    *\n    * - `account` cannot be the zero address.\n    * - `account` must have at least `amount` tokens.\n    * - the caller must be an operator for `account`.\n  */\n  function operatorBurn(\n    address account,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n  event Sent(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  function decimals() external returns (uint8);\n\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n  // ERC20 METHODS\n\n  /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\n    * allowance mechanism. `amount` is then deducted from the caller's\n    * allowance.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n  */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  // ISideToken METHODS\n\n  function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\n}"
    },
    "contracts/ISwapRBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISwapRBTC {\n\n  function swapWRBTCtoRBTC(uint256 amount) external returns (uint256);\n\n  function getSideTokenBtc() external view returns (address);\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}